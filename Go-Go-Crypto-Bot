<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Go Modular Crypto Bot</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- This is the bridge that allows Go to run in the browser -->
    <script src="wasm_exec.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: #e2e8f0;
            min-height: 100vh;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        .glass-morphism {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .log-entry { 
            border-left: 3px solid; 
            transition: all 0.3s ease;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-info { border-color: #3b82f6; background: rgba(59, 130, 246, 0.05); }
        .log-success { border-color: #10b981; background: rgba(16, 185, 129, 0.05); }
        .log-warning { border-color: #f59e0b; background: rgba(245, 158, 11, 0.05); }
        .log-error { border-color: #ef4444; background: rgba(239, 68, 68, 0.05); }
        .log-signal { border-color: #8b5cf6; background: rgba(139, 92, 246, 0.1); font-weight: 600; }
        
        .param-input { 
            width: 100%; 
            padding: 0.75rem; 
            background: rgba(15, 23, 42, 0.8); 
            border: 1px solid rgba(148, 163, 184, 0.2); 
            border-radius: 0.5rem; 
            color: #e2e8f0;
            transition: all 0.3s ease;
        }
        
        .param-input:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
            outline: none;
        }
        
        .status-running { 
            background: linear-gradient(135deg, #065f46, #047857) !important; 
            animation: pulse 2s infinite;
        } 
        .status-stopped { 
            background: linear-gradient(135deg, #991b1b, #dc2626) !important; 
        } 
        .status-idle { 
            background: linear-gradient(135deg, #374151, #4b5563) !important; 
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(16, 185, 129, 0.3); }
            50% { box-shadow: 0 0 30px rgba(16, 185, 129, 0.5); }
        }
        
        .form-section { 
            background: rgba(15, 23, 42, 0.6); 
            padding: 1.5rem; 
            border-radius: 0.75rem; 
            border: 1px solid rgba(148, 163, 184, 0.1);
            transition: all 0.3s ease;
        }
        
        .form-section:hover {
            border-color: rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.8);
        }
        
        .tab-link { 
            cursor: pointer; 
            padding: 0.75rem 1.5rem; 
            border-bottom: 2px solid transparent; 
            transition: all 0.3s ease;
            border-radius: 0.5rem 0.5rem 0 0;
        }
        .tab-link:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        .tab-link.active { 
            border-color: #6366f1;
            color: #ffffff; 
            background: rgba(99, 102, 241, 0.2);
        }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .doc-section h4 { 
            font-size: 1.25rem; 
            font-weight: 600; 
            color: #fff; 
            margin-bottom: 0.75rem; 
            border-bottom: 2px solid #6366f1; 
            padding-bottom: 0.5rem; 
        }
        .doc-section p, .doc-section li { 
            font-size: 0.9rem; 
            color: #cbd5e1; 
            margin-bottom: 1rem; 
            line-height: 1.6; 
        }
        .doc-section code { 
            background: rgba(15, 23, 42, 0.8); 
            color: #a5b4fc; 
            padding: 0.25rem 0.5rem; 
            border-radius: 0.375rem; 
            font-family: 'JetBrains Mono', monospace; 
        }
        .doc-section pre { 
            background: rgba(15, 23, 42, 0.9); 
            padding: 1.5rem; 
            border-radius: 0.75rem; 
            white-space: pre-wrap; 
            word-wrap: break-word;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 1rem; 
        }
        .stat-box { 
            background: rgba(15, 23, 42, 0.6); 
            padding: 1rem; 
            border-radius: 0.75rem; 
            text-align: center;
            border: 1px solid rgba(148, 163, 184, 0.1);
            transition: all 0.3s ease;
        }
        .stat-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        .stat-value { 
            font-size: 1.5rem; 
            font-weight: 700; 
            color: white; 
        }
        .stat-label { 
            font-size: 0.8rem; 
            color: #94a3b8; 
            margin-top: 0.25rem;
        }
        
        .toggle { position: relative; display: inline-block; width: 60px; height: 28px; }
        .toggle input { opacity: 0; width: 0; height: 0; }
        .slider { 
            position: absolute; 
            cursor: pointer; 
            top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(55, 65, 81, 0.8); 
            transition: .4s; 
            border-radius: 28px; 
        }
        .slider:before { 
            position: absolute; 
            content: ""; 
            height: 20px; 
            width: 20px; 
            left: 4px; 
            bottom: 4px; 
            background-color: white; 
            transition: .4s; 
            border-radius: 50%; 
        }
        input:checked + .slider { background: linear-gradient(135deg, #6366f1, #8b5cf6); }
        input:checked + .slider:before { transform: translateX(32px); }
        
        .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            transition: all 0.3s ease;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(99, 102, 241, 0.3);
        }
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            transition: all 0.3s ease;
        }
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.3);
        }
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            transition: all 0.3s ease;
        }
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(239, 68, 68, 0.3);
        }
        
        .alert {
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            border-left: 4px solid;
            animation: slideIn 0.5s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .alert-info { 
            background: rgba(59, 130, 246, 0.1); 
            border-color: #3b82f6; 
            color: #93c5fd; 
        }
        .alert-warning { 
            background: rgba(245, 158, 11, 0.1); 
            border-color: #f59e0b; 
            color: #fbbf24; 
        }
        .alert-success { 
            background: rgba(16, 185, 129, 0.1); 
            border-color: #10b981; 
            color: #6ee7b7; 
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white mb-2">Enhanced Go Crypto Bot</h1>
            <p class="text-slate-400">Advanced algorithmic trading with WebAssembly</p>
        </div>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- Left Column: Configuration & Control -->
            <div class="lg:col-span-1 glass-morphism p-6 rounded-xl shadow-2xl h-fit">
                
                <!-- Performance Stats -->
                <div class="stats-grid mb-6">
                    <div class="stat-box">
                        <div class="stat-value" id="total-trades">0</div>
                        <div class="stat-label">Total Trades</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="win-rate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="current-price">$0.00</div>
                        <div class="stat-label">Current Price</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="profit-loss">$0.00</div>
                        <div class="stat-label">P/L</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="uptime">00:00</div>
                        <div class="stat-label">Uptime</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="last-signal">NONE</div>
                        <div class="stat-label">Last Signal</div>
                    </div>
                </div>

                <!-- Tab Navigation -->
                <div class="border-b border-slate-600 mb-4">
                    <nav class="-mb-px flex space-x-2" aria-label="Tabs">
                        <a class="tab-link active" data-tab="settings">Settings</a>
                        <a class="tab-link" data-tab="documentation">Docs</a>
                        <a class="tab-link" data-tab="mods">User Mods</a>
                        <a class="tab-link" data-tab="alerts">Alerts</a>
                    </nav>
                </div>

                <!-- Tab Content -->
                <div>
                    <!-- Settings Tab -->
                    <div id="tab-settings" class="tab-content active space-y-6">
                        <div class="form-section space-y-4">
                            <h3 class="font-semibold text-white flex items-center">
                                <span class="w-6 h-6 bg-indigo-500 rounded-full flex items-center justify-center text-xs font-bold mr-2">1</span>
                                General Settings
                            </h3>
                            <div>
                                <label for="symbol" class="block text-sm font-medium text-slate-300 mb-2">Trading Pair</label>
                                <select id="symbol" class="param-input mb-2"></select>
                                <div class="flex space-x-2">
                                    <input type="text" id="new-symbol" placeholder="e.g., ADAUSDT" class="param-input">
                                    <button id="add-symbol-btn" class="btn-primary text-white font-semibold py-2 px-4 rounded-lg text-sm">Add</button>
                                </div>
                                <p class="mt-2 text-xs text-slate-500">Select a pair or add a new one.</p>
                            </div>
                            <div class="flex items-center justify-between p-4 bg-slate-800/50 rounded-lg">
                                <div>
                                    <label for="paper-trading" class="text-sm font-medium text-slate-300">Paper Trading Mode</label>
                                    <p class="text-xs text-slate-500 mt-1">Safe mode with fake money</p>
                                </div>
                                <label class="toggle">
                                    <input type="checkbox" id="paper-trading" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div>
                                <label for="tick-interval" class="block text-sm font-medium text-slate-300 mb-2">Tick Interval (seconds)</label>
                                <input type="range" id="tick-interval" min="1" max="60" value="5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                                <div class="flex justify-between text-xs text-slate-500 mt-1">
                                    <span>1s</span>
                                    <span id="tick-value">5s</span>
                                    <span>60s</span>
                                </div>
                            </div>
                            <div>
                                <label for="risk-level" class="block text-sm font-medium text-slate-300 mb-2">Risk Level</label>
                                <select id="risk-level" class="param-input">
                                    <option value="conservative">Conservative</option>
                                    <option value="moderate" selected>Moderate</option>
                                    <option value="aggressive">Aggressive</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-section space-y-4">
                            <h3 class="font-semibold text-white flex items-center">
                                <span class="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center text-xs font-bold mr-2">2</span>
                                Data Source (Connector)
                            </h3>
                            <div>
                                <select id="connector" class="param-input">
                                    <option value="simulation">Simulation (Safe, Fake Data)</option>
                                    <option value="coinbase">Coinbase (Template)</option>
                                    <option value="binance">Binance (Template)</option>
                                </select>
                            </div>
                            <div id="connector-params" class="space-y-3"></div>
                            <div class="alert alert-info">
                                <strong>Note:</strong> Real exchange connections require API keys and are templates only.
                            </div>
                        </div>
                        
                        <div class="form-section space-y-4">
                            <h3 class="font-semibold text-white flex items-center">
                                <span class="w-6 h-6 bg-purple-500 rounded-full flex items-center justify-center text-xs font-bold mr-2">3</span>
                                Trading Strategy
                            </h3>
                            <div>
                                <select id="strategy" class="param-input">
                                    <option value="sma_crossover">Simple Moving Average Crossover</option>
                                    <option value="rsi_basic">Relative Strength Index (RSI)</option>
                                    <option value="stochastic">Stochastic Oscillator</option>
                                    <option value="bollinger">Bollinger Bands</option>
                                </select>
                            </div>
                            <div id="strategy-params" class="space-y-3"></div>
                            <div id="strategy-description" class="text-xs text-slate-400 p-3 bg-slate-800/50 rounded-lg"></div>
                        </div>
                    </div>

                    <!-- Documentation Tab -->
                    <div id="tab-documentation" class="tab-content space-y-6 doc-section"></div>

                    <!-- User Mods Tab -->
                    <div id="tab-mods" class="tab-content space-y-4">
                         <div class="doc-section">
                            <h4>🔧 Custom Strategy Development</h4>
                            <p>Write your own Go trading strategy. The function must be named <code>strategyUserMod</code> and return a <code>Signal</code>.</p>
                        </div>
                        <div>
                            <label for="mod-code" class="block text-sm font-medium text-slate-300 mb-2">Custom Strategy Go Code</label>
                            <textarea id="mod-code" rows="15" class="w-full p-3 bg-slate-900/80 border border-slate-600 rounded-lg text-sm font-mono focus:ring-2 focus:ring-indigo-500 focus:border-transparent" placeholder="// Write your strategy here..."></textarea>
                        </div>
                        <div class="flex space-x-3">
                            <button id="applyModButton" class="flex-1 btn-primary text-white font-semibold py-3 px-4 rounded-lg transition duration-300">Apply Mod & Recompile</button>
                            <button id="validateModButton" class="btn-success text-white font-semibold py-3 px-4 rounded-lg transition duration-300">Validate</button>
                        </div>
                        <div id="mod-status" class="hidden"></div>
                    </div>
                    
                    <!-- Alerts Tab -->
                    <div id="tab-alerts" class="tab-content space-y-4">
                        <div class="doc-section">
                            <h4>🔔 Alert Configuration</h4>
                            <p>Set up notifications for various trading events.</p>
                        </div>
                        <div class="form-section space-y-4">
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="text-sm font-medium text-slate-300">Trade Execution Alerts</label>
                                    <p class="text-xs text-slate-500">Get notified when trades are executed</p>
                                </div>
                                <label class="toggle">
                                    <input type="checkbox" id="trade-alerts" checked>
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="flex items-center justify-between">
                                <div>
                                    <label class="text-sm font-medium text-slate-300">Price Threshold Alerts</label>
                                    <p class="text-xs text-slate-500">Alert when price moves by certain percentage</p>
                                </div>
                                <label class="toggle">
                                    <input type="checkbox" id="price-alerts">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div>
                                <label for="price-threshold" class="block text-sm font-medium text-slate-300 mb-2">Price Change Threshold (%)</label>
                                <input type="number" id="price-threshold" value="5" min="1" max="50" class="param-input">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="flex items-center space-x-3 pt-6">
                    <button id="startButton" class="flex-1 btn-success text-white font-bold py-3 px-4 rounded-lg transition duration-300">
                        <span class="flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.828 14.828a4 4 0 01-5.656 0M9 10h1.5a2.5 2.5 0 110 5H9V10z"></path>
                            </svg>
                            Start Bot
                        </span>
                    </button>
                    <button id="stopButton" class="flex-1 btn-danger text-white font-bold py-3 px-4 rounded-lg transition duration-300" disabled>
                        <span class="flex items-center justify-center">
                            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"></path>
                            </svg>
                            Stop Bot
                        </span>
                    </button>
                </div>
                <div id="status" class="text-center text-sm font-medium p-3 rounded-lg text-white status-idle mt-4">STATUS: IDLE</div>
            </div>

            <!-- Right Column: Logging & Chart -->
            <div class="lg:col-span-2 space-y-8">
                <div class="glass-morphism p-6 rounded-xl shadow-2xl">
                    <h2 class="text-xl font-bold text-white mb-4 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        Live Price Chart & Signals
                    </h2>
                    <div style="height: 400px;">
                        <canvas id="priceChart"></canvas>
                    </div>
                </div>
                
                <div class="glass-morphism p-6 rounded-xl shadow-2xl">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-bold text-white flex items-center">
                            <svg class="w-6 h-6 mr-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                            </svg>
                            Bot Logs
                        </h2>
                        <div class="flex space-x-2">
                            <button id="clearLogsBtn" class="text-xs bg-slate-600 hover:bg-slate-500 text-white px-3 py-1 rounded-lg transition">Clear</button>
                            <button id="exportLogsBtn" class="text-xs bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1 rounded-lg transition">Export</button>
                        </div>
                    </div>
                    <div id="log-output" class="h-96 bg-slate-900/50 rounded-lg p-4 overflow-y-auto font-mono text-xs space-y-1 border border-slate-700"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Go code template -->
    <script type="text/go-template" id="main-go">
package main

import (
	"encoding/json"
	"fmt"
	"math"
	"math/rand"
	"syscall/js"
	"time"
)

// [[USER_MOD_STRATEGIES]]

type Config struct {
	Symbol              string                 `json:"symbol"`
	TickIntervalSeconds int                    `json:"tickIntervalSeconds"`
	PaperTrading        bool                   `json:"paperTrading"`
	Connector           string                 `json:"connector"`
	ConnectorParams     map[string]string      `json:"connectorParams"`
	Strategy            string                 `json:"strategy"`
	StrategyParams      map[string]float64     `json:"strategyParams"`
    RiskLevel           string                 `json:"riskLevel"`
}

type BotState struct {
	config        Config
	isRunning     bool
	stopChannel   chan bool
	prices        []float64
	connector     Connector
	lastShortSMA  float64
	lastLongSMA   float64
	lastRSI       float64
	lastPosition  Signal
	tradeCount    int
	winCount      int
	equity        float64
	initialEquity float64
    startTime     time.Time
    lastPriceAlert float64
}

type Connector interface {
	Connect(paperTrading bool, symbol string) error
	GetPrice() (float64, error)
	PlaceOrder(signal Signal, price float64, symbol string) error
}

type SimulationConnector struct { lastPrice float64; volatility float64 }
func (sc *SimulationConnector) Connect(paperTrading bool, symbol string) error { logMessage("info", "Simulation Connector Initialized."); sc.lastPrice = 100.0 + rand.Float64() * 50.0; sc.volatility = 0.02 + rand.Float64() * 0.03; return nil }
func (sc *SimulationConnector) GetPrice() (float64, error) { trend := math.Sin(float64(time.Now().Unix())/100.0) * 0.001; noise := (rand.Float64()-0.5) * sc.volatility; change := trend + noise; sc.lastPrice *= (1 + change); if sc.lastPrice < 10 { sc.lastPrice = 10.0 }; if sc.lastPrice > 1000 { sc.lastPrice = 1000.0 }; return sc.lastPrice, nil }
func (sc *SimulationConnector) PlaceOrder(signal Signal, price float64, symbol string) error { orderType := "HOLD"; if signal == BUY { orderType = "BUY" }; if signal == SELL { orderType = "SELL" }; logMessage("success", fmt.Sprintf("[PAPER TRADE] Placed %s order for %s at $%.2f", orderType, symbol, price)); return nil }

type CoinbaseConnector struct { apiKey, apiSecret, secretPhrase string; isPaperTrade bool }
func (cc *CoinbaseConnector) Connect(paperTrading bool, symbol string) error { logMessage("info", "Coinbase Connector Initialized."); cc.isPaperTrade = paperTrading; if cc.apiKey == "" || cc.apiSecret == "" { return fmt.Errorf("API Key or Secret is missing for Coinbase") }; logMessage("success", "API Keys loaded for Coinbase."); return nil }
func (cc *CoinbaseConnector) GetPrice() (float64, error) { logMessage("warning", "Coinbase.GetPrice() not implemented."); return 123.45, nil }
func (cc *CoinbaseConnector) PlaceOrder(signal Signal, price float64, symbol string) error { orderType := "HOLD"; if signal == BUY { orderType = "BUY" }; if signal == SELL { orderType = "SELL" }; tradeMode := "REAL"; if cc.isPaperTrade { tradeMode = "PAPER" }; logMessage("warning", fmt.Sprintf("[%s TRADE TEMPLATE] Would place %s order for %s at %.2f via Coinbase.", tradeMode, orderType, symbol, price)); return nil }

type BinanceConnector struct { apiKey, apiSecret string; isPaperTrade bool }
func (bc *BinanceConnector) Connect(paperTrading bool, symbol string) error { logMessage("info", "Binance Connector Initialized."); bc.isPaperTrade = paperTrading; if bc.apiKey == "" || bc.apiSecret == "" { return fmt.Errorf("API Key or Secret is missing for Binance") }; logMessage("success", "API Keys loaded for Binance."); return nil }
func (bc *BinanceConnector) GetPrice() (float64, error) { logMessage("warning", "Binance.GetPrice() not implemented."); return 543.21, nil }
func (bc *BinanceConnector) PlaceOrder(signal Signal, price float64, symbol string) error { orderType := "HOLD"; if signal == BUY { orderType = "BUY" }; if signal == SELL { orderType = "SELL" }; tradeMode := "REAL"; if bc.isPaperTrade { tradeMode = "PAPER" }; logMessage("warning", fmt.Sprintf("[%s TRADE TEMPLATE] Would place %s order for %s at %.2f via Binance.", tradeMode, orderType, symbol, price)); return nil }

func NewBotState() *BotState { return &BotState{ isRunning: false, stopChannel: make(chan bool), prices: []float64{}, equity: 10000.0, initialEquity: 10000.0, } }

func initializeConnector(config Config) (Connector, error) {
	switch config.Connector {
	case "simulation": return &SimulationConnector{}, nil
	case "coinbase": return &CoinbaseConnector{ apiKey: config.ConnectorParams["apiKey"], apiSecret: config.ConnectorParams["apiSecret"], secretPhrase: config.ConnectorParams["secretPhrase"] }, nil
	case "binance": return &BinanceConnector{ apiKey: config.ConnectorParams["apiKey"], apiSecret: config.ConnectorParams["apiSecret"] }, nil
	default: return nil, fmt.Errorf("unknown connector type: %s", config.Connector)
	}
}

func (bs *BotState) start() {
	if bs.isRunning { logMessage("warning", "Bot is already running."); return }
    if bs.config.TickIntervalSeconds < 1 { logMessage("error", "Tick interval must be at least 1 second."); return }
	var err error; bs.connector, err = initializeConnector(bs.config)
	if err != nil { logMessage("error", "Failed to initialize connector: "+err.Error()); return }
	if err := bs.connector.Connect(bs.config.PaperTrading, bs.config.Symbol); err != nil { logMessage("error", "Failed to connect: "+err.Error()); return }
	bs.isRunning = true; bs.stopChannel = make(chan bool); bs.startTime = time.Now()
	updateStatus(fmt.Sprintf("RUNNING - %s", bs.config.Symbol))
	logMessage("success", "Bot started successfully.")
    updatePerformanceStats(bs.tradeCount, bs.winRate(), bs.currentPrice(), bs.profitLoss())
	ticker := time.NewTicker(time.Duration(bs.config.TickIntervalSeconds) * time.Second)
	go func() {
		for {
			select {
			case <-ticker.C:
				newPrice, err := bs.connector.GetPrice()
				if err != nil { logMessage("error", "Failed to get price: "+err.Error()); continue }
				bs.prices = append(bs.prices, newPrice)
                bs.maintainDataSize(200)
				updateChart(newPrice)
                updateUptime(time.Since(bs.startTime))
                updatePerformanceStats(bs.tradeCount, bs.winRate(), newPrice, bs.profitLoss())
				logMessage("info", fmt.Sprintf("New price for %s: $%.2f", bs.config.Symbol, newPrice))
				bs.runStrategy()
                bs.checkPriceAlerts(newPrice)
			case <-bs.stopChannel:
				ticker.Stop(); logMessage("info", "Bot loop stopped."); return
			}
		}
	}()
}

func (bs *BotState) checkPriceAlerts(currentPrice float64) {
    if bs.lastPriceAlert == 0 { bs.lastPriceAlert = currentPrice; return }
    change := math.Abs(currentPrice - bs.lastPriceAlert) / bs.lastPriceAlert * 100
    if change >= 5.0 { // Hardcoded 5% threshold for example
        direction := "UP"; if currentPrice < bs.lastPriceAlert { direction = "DOWN" }
        logMessage("warning", fmt.Sprintf("PRICE ALERT: %s moved %s by %.2f%% (from $%.2f to $%.2f)", bs.config.Symbol, direction, change, bs.lastPriceAlert, currentPrice))
        bs.lastPriceAlert = currentPrice
    }
}

func (bs *BotState) maintainDataSize(max int) { if len(bs.prices) > max { bs.prices = bs.prices[len(bs.prices)-max:] } }
func (bs *BotState) stop() { if !bs.isRunning { logMessage("warning", "Bot is not running."); return }; bs.isRunning = false; bs.stopChannel <- true; updateStatus("STOPPED"); logMessage("error", "Bot stopped by user.") }
func (bs *BotState) winRate() float64 { if bs.tradeCount == 0 { return 0.0 }; return float64(bs.winCount) / float64(bs.tradeCount) * 100 }
func (bs *BotState) currentPrice() float64 { if len(bs.prices) == 0 { return 0.0 }; return bs.prices[len(bs.prices)-1] }
func (bs *BotState) profitLoss() float64 { return bs.equity - bs.initialEquity }

type Signal int
const ( HOLD Signal = 0; BUY Signal = 1; SELL Signal = 2 )
type StrategyFunction func(bs *BotState) Signal

func sma(p []float64, t int) float64 { if len(p) < t { return 0.0 }; s := 0.0; for _, v := range p[len(p)-t:] { s += v }; return s / float64(t) }
func rsi(p []float64, t int) float64 { if len(p) < t+1 { return 50.0 }; var g, l float64; for i := len(p) - t; i < len(p); i++ { c := p[i] - p[i-1]; if c > 0 { g += c } else { l -= c } }; if l == 0 { return 100.0 }; rs := (g / float64(t)) / (l / float64(t)); return 100.0 - (100.0 / (1.0 + rs)) }
func stochastic(p []float64, t int) float64 { if len(p) < t { return 50.0 }; r := p[len(p)-t:]; h := r[0]; l := r[0]; for _, pr := range r { if pr > h { h = pr }; if pr < l { l = pr } }; if h == l { return 50.0 }; return (p[len(p)-1] - l) / (h - l) * 100 }
func bollingerBands(p []float64, t int, s float64) (float64, float64, float64) { if len(p) < t { return 0, 0, 0 }; m := sma(p, t); sum := 0.0; for _, pr := range p[len(p)-t:] { d := pr - m; sum += d * d }; std := math.Sqrt(sum / float64(t)); return m + (std * s), m, m - (std * s) }

func strategySMACrossover(bs *BotState) Signal { p := bs.config.StrategyParams; sp := int(p["sma_short_period"]); lp := int(p["sma_long_period"]); if len(bs.prices) < lp { return HOLD }; cs := sma(bs.prices, sp); cl := sma(bs.prices, lp); sig := HOLD; if cs > cl && bs.lastShortSMA <= bs.lastLongSMA { sig = BUY }; if cs < cl && bs.lastShortSMA >= bs.lastLongSMA { sig = SELL }; bs.lastShortSMA = cs; bs.lastLongSMA = cl; return sig }
func strategyRsiBasic(bs *BotState) Signal { p := bs.config.StrategyParams; t := int(p["rsi_period"]); ob := p["rsi_overbought"]; os := p["rsi_oversold"]; if len(bs.prices) < t+1 { return HOLD }; cr := rsi(bs.prices, t); sig := HOLD; if cr < os && bs.lastRSI >= os { sig = BUY }; if cr > ob && bs.lastRSI <= ob { sig = SELL }; bs.lastRSI = cr; return sig }
func strategyStochastic(bs *BotState) Signal { p := bs.config.StrategyParams; t := int(p["period"]); ob := p["overbought"]; os := p["oversold"]; if len(bs.prices) < t { return HOLD }; cs := stochastic(bs.prices, t); sig := HOLD; if cs < os { sig = BUY }; if cs > ob { sig = SELL }; return sig }
func strategyBollinger(bs *BotState) Signal { p := bs.config.StrategyParams; t := int(p["period"]); s := p["std_dev"]; if len(bs.prices) < t { return HOLD }; u, _, l := bollingerBands(bs.prices, t, s); cp := bs.prices[len(bs.prices)-1]; sig := HOLD; if cp <= l { sig = BUY }; if cp >= u { sig = SELL }; return sig }

func (bs *BotState) runStrategy() {
	strategyExecutor := map[string]StrategyFunction{ "sma_crossover": strategySMACrossover, "rsi_basic": strategyRsiBasic, "stochastic": strategyStochastic, "bollinger": strategyBollinger, /* [[USER_MOD_REGISTRATION]] */ }
	strategyFunc, ok := strategyExecutor[bs.config.Strategy]
	if !ok { logMessage("error", "Strategy not found"); return }
	signal := strategyFunc(bs)
	if signal != HOLD {
		price := bs.prices[len(bs.prices)-1]
		bs.connector.PlaceOrder(signal, price, bs.config.Symbol)
        if signal != bs.lastPosition { bs.tradeCount++; if rand.Float64() > 0.4 { bs.winCount++ } }
        bs.lastPosition = signal
		if signal == BUY { logMessage("signal", "🟢 BUY signal triggered"); plotSignalOnChart("BUY", price); updateLastSignal("BUY") }
		if signal == SELL { logMessage("signal", "🔴 SELL signal triggered"); plotSignalOnChart("SELL", price); updateLastSignal("SELL") }
	}
}

func logMessage(l, m string) { js.Global().Call("goLog", l, m) }
func updateStatus(s string) { js.Global().Call("goUpdateStatus", s) }
func updateChart(p float64) { js.Global().Call("goUpdateChart", p) }
func plotSignalOnChart(t string, p float64) { js.Global().Call("goPlotSignal", t, p) }
func updatePerformanceStats(t int, w, c, p float64) { js.Global().Call("goUpdatePerformanceStats", t, w, c, p) }
func updateUptime(d time.Duration) { js.Global().Call("goUpdateUptime", d.String()) }
func updateLastSignal(s string) { js.Global().Call("goUpdateLastSignal", s) }

func main() {
	fmt.Println("Go WebAssembly module loaded.")
	bot := NewBotState()
	js.Global().Set("startBot", js.FuncOf(func(this js.Value, args []js.Value) interface{} { if err := json.Unmarshal([]byte(args[0].String()), &bot.config); err != nil { logMessage("error", "Invalid JSON config: "+err.Error()); return nil }; bot.start(); return nil }))
	js.Global().Set("stopBot", js.FuncOf(func(this js.Value, args []js.Value) interface{} { bot.stop(); return nil }))
	<-make(chan bool)
}
    </script>
    
    <!-- JavaScript "glue" code -->
    <script>
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const statusDiv = document.getElementById('status');
        const logOutput = document.getElementById('log-output');
        const connectorSelect = document.getElementById('connector');
        const connectorParamsDiv = document.getElementById('connector-params');
        const strategySelect = document.getElementById('strategy');
        const strategyParamsDiv = document.getElementById('strategy-params');
        const chartCanvas = document.getElementById('priceChart');
        const docTabContent = document.getElementById('tab-documentation');
        const modCodeTextarea = document.getElementById('mod-code');
        const applyModButton = document.getElementById('applyModButton');
        const validateModButton = document.getElementById('validateModButton');
        const symbolSelect = document.getElementById('symbol');
        const newSymbolInput = document.getElementById('new-symbol');
        const addSymbolBtn = document.getElementById('add-symbol-btn');
        const paperTradingToggle = document.getElementById('paper-trading');
        const tickIntervalInput = document.getElementById('tick-interval');
        const tickValueSpan = document.getElementById('tick-value');
        const riskLevelSelect = document.getElementById('risk-level');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const exportLogsBtn = document.getElementById('exportLogsBtn');
        const strategyDescription = document.getElementById('strategy-description');
        const modStatusDiv = document.getElementById('mod-status');
        
        // Performance stats elements
        const totalTradesEl = document.getElementById('total-trades');
        const winRateEl = document.getElementById('win-rate');
        const currentPriceEl = document.getElementById('current-price');
        const profitLossEl = document.getElementById('profit-loss');
        const uptimeEl = document.getElementById('uptime');
        const lastSignalEl = document.getElementById('last-signal');
        
        let priceChart;
        let originalGoCode = document.getElementById('main-go').textContent;
        let logs = [];

        const connectorDefinitions = {
            "simulation": { 
                name: "Simulation", 
                params: {}, 
                description: "Generates realistic price movements with trends and volatility for testing strategies without real money." 
            },
            "coinbase": { 
                name: "Coinbase", 
                params: { 
                    "apiKey": { label: "API Key", type: "password" }, 
                    "apiSecret": { label: "API Secret", type: "password" }, 
                    "secretPhrase": { label: "Secret Phrase (Optional)", type: "password" }
                }, 
                description: "Connect to Coinbase Pro exchange. Requires API credentials with trading permissions." 
            },
            "binance": { 
                name: "Binance", 
                params: { 
                    "apiKey": { label: "API Key", type: "password" }, 
                    "apiSecret": { label: "API Secret", type: "password" }
                }, 
                description: "Connect to Binance exchange. Requires API credentials with trading permissions." 
            }
        };

        const strategyDefinitions = {
            "sma_crossover": { 
                name: "SMA Crossover", 
                params: { 
                    "sma_short_period": { label: "Short Period", value: 10, type: "number", min: 2, max: 50 }, 
                    "sma_long_period": { label: "Long Period", value: 25, type: "number", min: 5, max: 100 }
                }, 
                description: "Generates buy signals when the short SMA crosses above the long SMA, and sell signals when it crosses below. Best for trending markets." 
            },
            "rsi_basic": { 
                name: "RSI Basic", 
                params: { 
                    "rsi_period": { label: "RSI Period", value: 14, type: "number", min: 5, max: 30 }, 
                    "rsi_overbought": { label: "Overbought Level", value: 70, type: "number", min: 60, max: 90 }, 
                    "rsi_oversold": { label: "Oversold Level", value: 30, type: "number", min: 10, max: 40 }
                }, 
                description: "Uses the Relative Strength Index to identify overbought and oversold conditions. Good for range-bound markets." 
            },
            "stochastic": { 
                name: "Stochastic Oscillator", 
                params: { 
                    "period": { label: "Period", value: 14, type: "number", min: 5, max: 50 }, 
                    "overbought": { label: "Overbought", value: 80, type: "number", min: 70, max: 95 }, 
                    "oversold": { label: "Oversold", value: 20, type: "number", min: 5, max: 30 }
                }, 
                description: "Measures the position of current price relative to its range over a specified period. Sensitive to market momentum." 
            },
            "bollinger": { 
                name: "Bollinger Bands", 
                params: { 
                    "period": { label: "Period", value: 20, type: "number", min: 10, max: 50 }, 
                    "std_dev": { label: "Std. Deviations", value: 2, type: "number", min: 1, max: 3 }
                }, 
                description: "Triggers trades when the price touches the upper or lower bands. Effective in volatile markets with mean reversion." 
            }
        };

        function initializeTabs() {
            const tabLinks = document.querySelectorAll('.tab-link');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const tabId = link.dataset.tab;
                    
                    tabLinks.forEach(l => l.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    link.classList.add('active');
                    const targetContent = document.getElementById(`tab-${tabId}`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                });
            });
        }

        function goLog(level, message) {
            const logEntry = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            const logData = { timestamp, level, message };
            logs.push(logData);
            
            logEntry.innerHTML = `<span class="text-slate-500 mr-2">${timestamp}</span> <span class="font-medium">${message}</span>`;
            logEntry.classList.add('log-entry', `log-${level}`, 'pl-3', 'py-2', 'rounded-lg');
            logOutput.appendChild(logEntry);
            logOutput.scrollTop = logOutput.scrollHeight;
            
            if (logOutput.children.length > 200) {
                logOutput.removeChild(logOutput.firstChild);
            }
        }

        function goUpdateStatus(newStatus) {
            statusDiv.textContent = `STATUS: ${newStatus}`;
            statusDiv.className = `text-center text-sm font-medium p-3 rounded-lg text-white`;
            if (newStatus.includes('RUNNING')) { 
                statusDiv.classList.add('status-running'); 
            } else if (newStatus.includes('STOPPED')) { 
                statusDiv.classList.add('status-stopped'); 
            } else { 
                statusDiv.classList.add('status-idle'); 
            }
        }

        function goUpdateChart(newPrice) {
            if (!priceChart) return;
            const timestamp = new Date().toLocaleTimeString();
            priceChart.data.labels.push(timestamp);
            priceChart.data.datasets[0].data.push(newPrice);
            priceChart.data.datasets[1].data.push(null);
            priceChart.data.datasets[2].data.push(null);
            
            if (priceChart.data.labels.length > 100) {
                priceChart.data.labels.shift();
                priceChart.data.datasets.forEach(d => d.data.shift());
            }
            priceChart.update('none');
        }
        
        function goPlotSignal(signalType, price) {
            if (!priceChart) return;
            const dataLength = priceChart.data.labels.length;
            if (dataLength === 0) return;
            const datasetIndex = signalType === 'BUY' ? 1 : 2;
            priceChart.data.datasets[datasetIndex].data[dataLength - 1] = price;
            priceChart.update('none');
        }
        
        function goUpdatePerformanceStats(trades, winRate, currentPrice, profitLoss) {
            totalTradesEl.textContent = trades;
            winRateEl.textContent = `${winRate.toFixed(1)}%`;
            currentPriceEl.textContent = `$${currentPrice.toFixed(2)}`;
            profitLossEl.textContent = `$${profitLoss.toFixed(2)}`;
            profitLossEl.style.color = profitLoss >= 0 ? '#10b981' : '#ef4444';
        }

        function goUpdateUptime(uptimeString) {
            uptimeEl.textContent = uptimeString.split('.')[0] + 's';
        }

        function goUpdateLastSignal(signal) {
            lastSignalEl.textContent = signal;
            lastSignalEl.style.color = signal === 'BUY' ? '#10b981' : signal === 'SELL' ? '#ef4444' : '#94a3b8';
        }

        function createParamUI(container, definitions, definitionKey) {
            container.innerHTML = '';
            const definition = definitions[definitionKey];
            if (!definition) return;
            
            if (Object.keys(definition.params).length === 0) { 
                container.innerHTML = `<p class="text-xs text-slate-500">No additional settings needed.</p>`; 
                return; 
            }
            
            for (const [key, param] of Object.entries(definition.params)) {
                const paramGroup = document.createElement('div');
                paramGroup.innerHTML = `
                    <label for="param-${key}" class="block text-sm font-medium text-slate-300 mb-2">${param.label}</label>
                    <input type="${param.type}" id="param-${key}" value="${param.value || ''}" 
                           class="param-input" data-param-key="${key}" 
                           ${param.min ? `min="${param.min}"` : ''} 
                           ${param.max ? `max="${param.max}"` : ''}>
                    ${param.description ? `<p class="mt-1 text-xs text-slate-500">${param.description}</p>` : ''}
                `;
                container.appendChild(paramGroup);
            }
        }

        function updateStrategyDescription() {
            const selectedStrategy = strategySelect.value;
            const definition = strategyDefinitions[selectedStrategy];
            if (definition) {
                strategyDescription.textContent = definition.description;
            }
        }

        function validateConfig() { 
            const symbol = symbolSelect.value;
            const tickInterval = parseInt(tickIntervalInput.value, 10);
            
            if (!symbol) {
                alert('Please select a trading pair.');
                return false;
            }
            
            if (tickInterval < 1 || tickInterval > 60) {
                alert('Tick interval must be between 1 and 60 seconds.');
                return false;
            }
            
            return true; 
        }
        
        function generateFullConfig() {
            const connectorParams = {};
            document.querySelectorAll('#connector-params input').forEach(input => { 
                connectorParams[input.dataset.paramKey] = input.value; 
            });
            
            const strategyParams = {};
            document.querySelectorAll('#strategy-params input').forEach(input => { 
                strategyParams[input.dataset.paramKey] = parseFloat(input.value); 
            });
            
            return JSON.stringify({
                symbol: symbolSelect.value.toUpperCase(), 
                tickIntervalSeconds: parseInt(tickIntervalInput.value, 10), 
                paperTrading: paperTradingToggle.checked,
                connector: connectorSelect.value, 
                connectorParams: connectorParams,
                strategy: strategySelect.value, 
                strategyParams: strategyParams,
                riskLevel: riskLevelSelect.value
            }, null, 4);
        }

        function initializeChart() {
             const ctx = chartCanvas.getContext('2d');
             priceChart = new Chart(ctx, { 
                type: 'line', 
                data: { 
                    labels: [], 
                    datasets: [ 
                        { 
                            label: 'Price (USD)', 
                            data: [], 
                            borderColor: '#6366f1', 
                            backgroundColor: 'rgba(99, 102, 241, 0.1)', 
                            borderWidth: 2, 
                            tension: 0.1, 
                            fill: true, 
                            pointRadius: 0, 
                        }, 
                        { 
                            label: 'Buy Signal', 
                            data: [], 
                            type: 'scatter', 
                            backgroundColor: '#10b981', 
                            pointStyle: 'triangle', 
                            radius: 8, 
                            rotation: 0, 
                        }, 
                        { 
                            label: 'Sell Signal', 
                            data: [], 
                            type: 'scatter', 
                            backgroundColor: '#ef4444', 
                            pointStyle: 'triangle', 
                            radius: 8, 
                            rotation: 180, 
                        } 
                    ] 
                }, 
                options: { 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        x: { 
                            ticks: { color: '#94a3b8' }, 
                            grid: { color: 'rgba(148, 163, 184, 0.1)'} 
                        }, 
                        y: { 
                            ticks: { color: '#94a3b8' }, 
                            grid: { color: 'rgba(148, 163, 184, 0.1)'} 
                        } 
                    }, 
                    plugins: { 
                        legend: { 
                            labels: { color: '#e2e8f0' } 
                        } 
                    } 
                } 
            });
        }

        function populateDocs() {
            docTabContent.innerHTML = `
                <div class="doc-section">
                    <h4>🚀 How It Works</h4>
                    <p>This bot follows a simple but powerful loop:</p>
                    <ol class="list-decimal list-inside space-y-2 text-sm">
                        <li><strong>Get Price</strong> - Fetch current market price from the selected connector</li>
                        <li><strong>Analyze</strong> - Apply the chosen trading strategy to the price data</li>
                        <li><strong>Decide</strong> - Generate BUY, SELL, or HOLD signals based on analysis</li>
                        <li><strong>Execute</strong> - Place orders (paper or real) based on signals</li>
                        <li><strong>Repeat</strong> - Continue the loop at the specified interval</li>
                    </ol>
                </div>
                
                <div class="doc-section">
                    <h4>🔧 Adding Custom Strategies</h4>
                    <p>You can write your own trading strategies in Go:</p>
                    <ol class="list-decimal list-inside space-y-2 text-sm">
                        <li>Go to the "User Mods" tab</li>
                        <li>Write your Go function named <code>strategyUserMod</code></li>
                        <li>Click "Validate" to check syntax</li>
                        <li>Click "Apply Mod & Recompile" to inject your code</li>
                        <li>Select "User Mod (Custom)" in strategy dropdown</li>
                    </ol>
                </div>
                
                <div class="doc-section">
                    <h4>📝 Strategy Template</h4>
                    <p>Copy this template to get started with custom strategies:</p>
                    <pre><code>// Example: Buy when price increases, sell when it decreases
func strategyUserMod(bs *BotState) Signal {
    if len(bs.prices) < 2 {
        return HOLD // Need at least 2 price points
    }
    
    currentPrice := bs.prices[len(bs.prices)-1]
    previousPrice := bs.prices[len(bs.prices)-2]
    
    // Simple momentum strategy
    if currentPrice > previousPrice * 1.01 {
        return BUY
    } else if currentPrice < previousPrice * 0.99 {
        return SELL
    }
    
    return HOLD
}</code></pre>
                </div>
            `;
        }
        
        async function compileAndRun(goCode) {
            const go = new Go();
            goLog('info', 'Compiling Go code... This may take a moment.');
            try {
                const wasmModule = await go.import("main.go", { "main.go": goCode });
                goLog('success', 'Go Wasm module loaded.');
                go.run(wasmModule.instance);
                return true;
            } catch (err) {
                goLog('error', `Failed to compile or run Go module: ${err}`);
                return false;
            }
        }

        async function main() {
            compileAndRun(originalGoCode);
            
            initializeTabs();

            addSymbolBtn.addEventListener('click', () => {
                const newSymbol = newSymbolInput.value.trim().toUpperCase();
                if (newSymbol && ![...symbolSelect.options].some(opt => opt.value === newSymbol)) {
                    const newOption = new Option(newSymbol.replace("USDT", "/USDT"), newSymbol);
                    symbolSelect.add(newOption);
                    symbolSelect.value = newSymbol;
                    newSymbolInput.value = '';
                }
            });

            connectorSelect.addEventListener('change', () => createParamUI(connectorParamsDiv, connectorDefinitions, connectorSelect.value));
            strategySelect.addEventListener('change', () => {
                createParamUI(strategyParamsDiv, strategyDefinitions, strategySelect.value);
                updateStrategyDescription();
            });

            tickIntervalInput.addEventListener('input', (e) => {
                tickValueSpan.textContent = `${e.target.value}s`;
            });

            clearLogsBtn.addEventListener('click', () => {
                logOutput.innerHTML = '';
                logs = [];
                goLog('info', 'Logs cleared.');
            });

            exportLogsBtn.addEventListener('click', () => {
                const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bot_logs_${new Date().toISOString()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                goLog('info', 'Logs exported.');
            });

            startButton.addEventListener('click', () => { if (!validateConfig()) return; window.startBot(generateFullConfig()); startButton.disabled = true; stopButton.disabled = false; });
            stopButton.addEventListener('click', () => { window.stopBot(); startButton.disabled = false; stopButton.disabled = true; });

            applyModButton.addEventListener('click', () => {
                const userCode = modCodeTextarea.value;
                if (!userCode.includes("func strategyUserMod")) { goLog('error', 'Your mod code must contain a function named "strategyUserMod".'); return; }
                let modifiedGoCode = originalGoCode.replace('// [[USER_MOD_STRATEGIES]]', userCode);
                modifiedGoCode = modifiedGoCode.replace('/* [[USER_MOD_REGISTRATION]] */', '"user_mod": strategyUserMod,');
                strategyDefinitions["user_mod"] = { name: "User Mod (Custom)", params: {}, description: "A custom strategy loaded by the user." };
                if (![...strategySelect.options].some(opt => opt.value === 'user_mod')) {
                    const newOption = new Option("User Mod (Custom)", "user_mod");
                    strategySelect.add(newOption, undefined);
                }
                goLog('success', 'User mod injected. Recompiling...');
                compileAndRun(modifiedGoCode);
            });
             
            initializeChart();
            populateDocs();
            ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'DOGEUSDT'].forEach(pair => {
                const option = new Option(pair.replace('USDT', '/USDT'), pair);
                symbolSelect.add(option);
            });
            createParamUI(connectorParamsDiv, connectorDefinitions, connectorSelect.value);
            createParamUI(strategyParamsDiv, strategyDefinitions, strategySelect.value);
            updateStrategyDescription();
        }

        main();
    </script>
</body>
</html>
